# HTTP 공부하기 02

<br>
<br>
<br>

## HTTP 상태코드

http 상태코드는 클라이언트가 보낸 요청의 처리상태를 응답에서 알려주는 기능이다.
크게 100,200,300,400,500대 로 나뉘어져 구분되어 있다.

<br>

* 1xx (Informational): 요청이 수신되어 처리중
* 2xx (Successful): 요청이 정상적으로 처리 됨
* 3xx (Redirection): 요청을 완료하려면 클라이언트 측에서 추가 행동이 필요하다는 의미인데 리다이렉션을 의미하는 경우도 많다. (HTTP Response 메세지에 Header Field에 Location 값이 있으면 리다이렉션 됨)
* 4xx (Client Error): 클라이언트 측에서 오류 발생, 잘못된 문법등으로 서버가 요청을 수행할 수 없음
* 5xx (Server Error): 서버 측에서 오류 발생, 서버가 정상 요청을 처리하지 못함



### 자주 사용되는 상태코드

더 자세항 설명은 [여기](https://developer.mozilla.org/ko/docs/Web/HTTP/Status) 를 참고하자

| 상태코드 | 설명 |
| ------ | ----- |
| 200 | ok, 정상적으로 처리 되었다. |
| 201 | created, 새로운 리소스가 생성 되었음을 의미한다, 201인 경우 http 응답헤더에 location 이라는 값으로 생성된 리소스의 uri를 넣어주는 경우가 많다. |
| 202 | accepted, 요청이 접수되었으나 처리가 완료되지 않았다. 예를들어 batch가 돌아야 실제 처리가 완료되는 경우인데 잘 안쓰인다. |
| 204 | NoContent요청을 성공적으로 수행했지만 별도로 내려줄 컨텐츠가 없는경우, 예를들어 `임시저장 save 버튼`을 눌러 임시데이터를 저장했는데 딱히 보여줄 건 없는경우 이다. |
| 300 | Mutiple Choices, 요청에 대한 응답이 여러개 이다, 사용자 에이전트(브라우저)는 여러개의 응답중 하나를 반드시 선택해야 한다, 선택방식은 표준이 없음. |
| 301 | Moved Permanently, 기존 리소스의 uri가 영구적으로 변경되었음을 의미한다, 검색엔진 에서도 변경됨을 인지할 수 있음 |
| 302 | Found, 요청 리소스 URI가 일시적으로 변경 되었음을 의미한다. (요청메서드/메세지바디 대부분 GET 으로 처리 하지만 명확하지 않다.) |
| 303 | See Other(en-US), 요청 리소스 URI가 일시적으로 변경 되었음을 의미한다. (요청메서드/메세지바디 무조건 GET 으로 처리 한다.) |
| 304 | Not Modified, 캐시를 목적으로 사용 된다. (리소스가 바뀐게 없으니 캐시를 재사용 하라는 의미)  |
| 307 | Temporary Redirect, 302/303과 같은 기능을 하는데 처음 요청당시 요청메서드/요청바디가 POST라면 유지한채로 리다이렉션 한다. |
| 308 | Permanent Redirect, 301과 같은 기능이나 리다이렉트 할 때 처음 요청이 POST메서드 이면 메서드와 메세지바디를 유지하며 리다이렉트 시킨다. (실제로는 쓸일이 없다. 리소스가 변했어도 api 요청 스펙도 변하기 때문에) |
| 400 | Bad Request, 클라이언트 요청이 api 스펙과 안맞아 서버가 처리를 못한다는 의미다. |
| 401 | Unauthorized, 클라이언트가 해당 리소스에 대한 인증을 해야한다. (Authentication = 인증/로그인이 안됐다, Authorization = 인가/권한이 없다.) |
| 403 | Forbidden, 접근 권한이 불충분해 서버가 승인을 거부하는 경우 |
| 404 | Not Found, 해당 리소스가 없는데 서버에 요청을 한 경우 혹은 해당 리소스를 숨기고 싶은경우에도 사용된다. |
| 500 | Internal Server Error, 서버 내부 오류로 발생한 경우 (애매하면 다 상태코드로 처리 가능) |
| 503 | Service Unavailable, 서비스 이용불가, 서버가 일시적 과부하 또는 예정된 작업으로 인해 잠시 요청을 처리할 수 없는경우, `Retry-After` 헤더 필드를 통해 언제 복구되는지를 알려줄 수도 있다. |

<br>

#### PRG: `Post/Redirect/Get` 이란?

post로 주문서를 생성한 이후에 웹브라우저에서 실수로 새로고침을 누른다면 의도와 다르게 중복으로 요청이 생성될 것이다. 이런 경우를 막기위해 응답을 GET으로 바꿔
응답해주면 새로고침을 해도 중복되는 오류를 막을 수 있다. (어차피 서버에서 주문서id를 통해 막겠지만 클라이언트 차원에서 방지할 수 있다)

1. POST `/orders`로 주문서 생성을 요청
2. 요청 처리이후 DB에 새 주문서 생성
3. 응답을 `200 ok`가 아닌 `302 Found`로 주고 응답헤더 로케이션에 `/orders/order-result/19`를 추가한다.
4. 브라우저는 리다이렉션된 곳에서 `GET /order-result/19`를 처리할 것이고 새로고침 해도 생성이 아닌 주문결과를 조회해 전달하게 된다.

<br>

## HTTP 헤더

http헤더에는 여러가지 값이 들어있는데 http 전송에 필요한 모든 부가정보가 들어있게 된다, 예를들어 메시지 바디의 내용, 메세지 바디의 크기, 압축, 인증, 요청 클라이언트정보
서버 정보, 캐시 관리 등등에 중요한 정보들이 많고 [표준 헤더](https://en.wikipedia.org/wiki/List_of_http_header_fields) 가 많다. 필요시 임의에 헤더를 추가할 수 있지만 클라이언트가 해당 추가필드를 처리하기로 약속되어야 한다.

<br>

### 과거 HTTP 헤더 (RFC2616)

* General 헤더: 메세지 전체에 적용되는 정보 예) Connection: close
* Request 헤더: 요청 정보 예) User-Agent: Mozilla/5.0
* Response 헤더: 응답 정보 예) Server: Apache
* Entity 헤더: 엔티티 바디 정보 예) Content-Type: text/html, Content-Length: 3512


HTTP 표준이 2014년 FRC7230 ~ 72235로 변경되면서 많은 부분이 개선되었다.
* 엔티티(Entity) 대신 표현(Representation) 이라는 개념으로 변경
* Representation = Representation Metadata + Representation Data 로 정의 된다.
* 표현 = 표현 메타데이터 + 표현 데이터
* 메세지 바디를 통해 표현 데이터를 전달한다
* 표현 페더는 표현 데이터(응답으로 전달할 실제 데이터)를 해석할 수 있는 데이터유형, 길이, 압축정보 등을 포함한다.

<br>

## 표현 헤더
* Content-Type: 표현 데이터의 형식
* Content-Encoding: 표현 데이터의 압축 방식
* Content-Language: 표현 데이터의 자연 언어
* Content-Length: 표현 데이터의 길이
* 표현 헤더는 전송, 응답 둘다 사용 가능하다

## 협상 헤더 (컨텐츠 네고시에이션)
HTTP의 헤더에는 여러가지 헤더가 있다, 그중 위에 써있는 표현헤더도 있고 협상 헤더도 있다.
협상 헤더는 클라이언트가 선호하는 표현으로 달라는 요청이다, 서버가 그 요청대로 응답하지 못할 수도 있다.

* Accept: 클라이언트가 선호하는 미디어 타입 전달 예) `text/*, text/plain, text/plain;format=flowed, */*`
* Accept-Charset: 클라이언트가 선호하는 문자 인코딩
* Accept-Encoding: 클라이언트가 선호하는 압축 인코딩
* Accept-Language: 클라이언트가 선호하는 자연 언어, Quality Values라고 해서 선호 언어의 우선순위를 정할 수 있다 예) `Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7`
* 협상 헤더는 요청시에만 사용된다.

![콘텐츠 헤더 이미지](../images/Screenshot%202021-07-25%20at%2011.04.11.jpg)

빨간색 줄쳐진 부분을 보자, 구글 검색에 요청된 `Accept-Language` 예시

<br>

### 기타 헤더
* FROM: 유저 에이전트의 이메일 정보
* Referer: 이전 웹 페이지의 주소 (뒤로가기를 누르면 가는 주소, 유입 경로를 확인하기 위한 수단으로 많이 쓴다.)
* User-Agent: 클라이언트 애플리케이션의 정보이다, 통계정보로 많이 쓰이고 어떤 종류의 브라우저에서 장애가 발생하는지 파악하기 위한 수단으로도 쓰인다.
* Server: 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보 (HTTP 요청을 보내면 중간에 여러 프록시 서버를 거치게 된다, 나의 요청을 처리해준 마지막 서버를 origin 서버라고 한다.)
* Data: 응답에서 메세지가 발생한 날짜와 시간
* Host: 요청한 호스트 정보 (도메인), 필수값이다 하나의 서버에 여러개의 애플리케이션이 여러개가 구동중일 수도 있기 때문에 반드시 포함 되어야 한다.
* Location: 페이지 리다이렉션 정보 (201이면 생성된 리소스, 3xx면 리다이렉션 주소)
* Allow: 허용 가능한 HTTP 메서드 예) `Allow: GET, HEAD, PUT`
* Retry-After: 503 에러인 경우 언제 다시 서비스를 이용할 수 있는지에 대한 정보
* Authorization: 클라이언트 인증 정보를 서버에 전달한다. 예) `Authorization: Basic xxxxx`
* WWW-Authenticate: 401에러가 발생하는 경우, 인증방법을 정의해서 보낼때 사용한다 예) `WWW-Authenticate: Newauth realm="apps", type=1, title="Login to\"apps\"", Basic realm="simple"`
* set-Cookie: 서버에서 클라이언트로 응답하는 쿠키
* Cookie: 클라이언트가 서버에서 받은 쿠키를 저장한 뒤, HTTP 요청시 서버로 전달 (쿠키가 있으면 브라우저는 모든 요청에 쿠키를 자동 포함한다.)

### 쿠키
* set-cookie: `sessionId=abcd1234; expires=Sat, 26-Dec-2021 00:00:00 GMT; path=/; domain=.google.com/; Secure`
* 사용자 로그인 세션 관리
* 광고 정보 트래킹
* 네트워크 트래픽 추가 유발
* 최소한의 정보만 사용 (세션 id, 인증 토큰 처럼 최소한의 정보만 사용)
* 서버에 전송하지 않고, 웹 내부 데이터를 사용하고 싶으면 localStorage 등을 사용한다.
* 보안에 민감한 데이터는 저장하면 안된다.
* Set-Cookie: `expires=Sat, 26-Dec-2021 06:00:00 GMT` 만료일이 되면 쿠키 삭제
* Set-Cookie: `max-age=3600` (3600초)
* 세션쿠키: 만료 날짜를 생략하면 브라우저 종료시 삭제된다.
* 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지된다.
* domain: `domain = example.com` (도메인을 명시하면 기준 도메인+ 서브도메인까지 모두 쿠키가 같이 전송된다.), 생략하게 되면 쿠키를 생성한 도메인에서만 접근되고 서브 도메인은 불가능하게 된다.
* path: 패스를 지정하면 해당 경로의 하위 페이지 에서만 쿠키 접근이 가능해진다. 일반적으로 `path=/` 처럼 루트로 지정한다.
* Secure: 쿠키는 원래 http, https를 구분하지 않는데 Secure가 적용되면 https인 경우에만 쿠키를 전송한다.
* HttpOnly: XSS 공격을 방지하기 위함, 자바스크립트 에서 쿠키에 접근하는것을 막는다 (document.cookie 불가)
* SameSite: XSRF 공격을 방지하기 위함, 요청 도메인과 쿠키에 설정된 도메인이 같아야만 쿠키를 전송한다.

## HTTP 캐시

* 데이터가 변경되지 않아도 계속 네트워크를 통해 데이터를 다운로드 받아야 한다.
* 인터넷 네트워크는 메모리나 하드디스크에 비해 느리고 코스트가 비싸다
* 브라우저 로딩 속도가 느려지고 안좋은 사용자 경험을 유발한다.

만약 캐싱처리가 안되어 있다면 용량이 큰 리소스(html, video, image 등)를 사용하는 경우 캐시가 없다면 요청될 때 마다 계속해서 큰 용량의 응답을 처리할 것이다.
`cache-control` 이라는 헤더 필드로 캐시가 유효한 시간을 지정할 수 있다. 웹 브라우저에는 내부에 캐시를 저장하는 저장소가 있다.
근데 캐시컨트롤에 적혀있는 유효시간을 지나면(만료되면) 당연히 다시 네트워크를 이용해 리소스를 다운로드 받는다.

이런 상황을 해결하기 위한 방법이 `검증 헤더와 조건부 요청`이다.

<br>

### 캐싱을 위한 방법 01 - 검증헤더

* Last-Modified: 리소스의 마지막 수정일을 표기한다. 예) `Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT`

위에서 처럼 캐시컨트롤을 통해 지정 시간까지 캐싱이 유효하다 라고 정할 수 있지만 시간이 지나면 다시 다운로드 받는다.
이런 해결을 위해 `Last-Modified`를 사용하면 된다.

1. 1번째 요청시 서버는 응답에 `Last-Modified`를 포함해 응답한다.
2. 2번째로 요청할 때 클라이언트가 `if-modified-since`를 포함한다.
3. 2번째 요청에 대한 확인을 할 때 서버는`if-modified-since`의 값과 리소스 최종 수정일을 비교한다
4. 수정한 값이 없다면 `304 Not Modified`로 응답해 준다. (HTTP Body가 없어야 한다.)
5. 304를 응답 받은 클라이언트는 캐싱되어 있던 리소스를 재사용 한다.
6. 결과적으로 네트워크 다운로드가 요청/응답이 발생하기는 하지만 바디가 생략되므로 훨씬 적은 비용만 사용하게 된다.

<br>

### 캐싱을 위한 방법 02 - ETag

위에서 확인한 방법은 변경된 데이터가 없는경우 다시 재사용하라는 해결바법 이였다.
그리고 날짜 기반의 로직을 사용하고 있다, 만약 데이터를 수정해 날짜는 다르지만 실질적인 데이터는 동일한 경우, 스페이스나 주석처럼 별 영향없는 변경에 캐시를 유지하고 싶은경우
등등 별도의 캐시 로직을 관리하고 싶은 경우에 필요한 것이 ETag(Entity Tag) 이다.
서버에서 임의에 버전이나 이름을 달아줄 수 있다, 데이터가 변경되면 태그이름을 바꿔서 변경되었음을 인지하는 것이다.
`if-None-Match` 헤더필드로 ETag를 전달한다.

* 동일한 파일을 해시로 바꾸면 컨텐츠가 같다면 해시값도 계속 동일하다.
* 각 데이터마다 ETag를 부여하고, 데이터가 변경되면 새 ETag를 붙인다.
* ETag가 바뀌었으면 데이터가 변경 된 것으로 인식 한다.

<br>

### 캐시와 관련된 헤더 필드
* Cache-Control: 캐시 제어를 위한 필드이다.
  * `Cache-Control: max-age=3600` 캐시 유효시간을 초단위로 지정한다.
  * `Cache-Control: no-cache` 데이터는 캐시해도 되지만, origin 서버(http 요청을 처리하는 실제 서버)에 검증하고 사용한다.
  * `Cache-Control: no-store` 데이터에 민감한 정보가 있으므로 저장하지 말라는 의미 (메모리에서 사용하고 최대한 빨리 삭제)
* Pragma: 캐시 제어, http 1.0 이하에서 사용하기 위한 하위호환인데 사용할 일이 없을 것 같다.
* Expires: 캐시 만료일을 지정하기 위함인데 `Cache-Control: max-age`를 권장한다, 사용할 일이 없을 것 같다.

### 프록시 캐시

만약 내가 현재 살고있는 경기도에서 미국 아마존 서버로 접속해 쇼핑과 관련된 이미지를 다운로드 하려고 할 때 1초가 걸린다고 하자,
이런 시간을 줄이기 위해 프록시 캐시 서버를 만들어 `한국 -> 미국` 이 아닌 `한국 -> 한국 어딘가에 있는 프록시 서버` 로 이미지를 다운로드 받는다면
훨씬 빠른 속도로 이용이 가능할 것이다. CDN 서비스 라고도 부른다, AWS 에서는 `클라우드 프론트`가 여기에 해당한다. 몇년전만 해도 아마존을 단순 쇼핑사이트로 생각했던 걸 생각하면
내가 너무 무식한 것 같다.

### 캐시 무효화
캐시 되면 안되는 경우가 존재할 수 있다, 캐시를 하지 말라고 해도 브라우저 내에서 임시로 캐시하는 경우도 있다고 한다.  `Cache-Control: no-cache, no-store, must-revalidate` 이렇게 캐시컨트롤을 추가하고 혹시
모를 HTTP 1.0 이하 버전을 위해 `Pragma: no-cache`도 추가해주면 된다.

작년에 물류사/관세사 관련 프로젝트를 진행한 적이 있는데 IE에서 캐싱이 되어서 자꾸만 물류사 리스트가 최신이 아닌 문제가 있었다.
```
axios.defaults.headers.common = {
  Pragma: 'no-cache'
}
```
위 코드로 처리가 되었는데 이 당시에는 이게 무슨의미인지 몰랐는데 지금은 이 글을 보는 분들도 의미를 알것이라 생각한다.  
확실하지 않지만 아마도 IE는 http 1.0을 쓰나보다..?